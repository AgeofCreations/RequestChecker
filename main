from Souce.ui import *
from PyQt5.Qt import *
import requests
import asyncio
import numpy as np
import time
#-------------------Обработка исключений--------------------------

def log_uncaught_exceptions(ex_cls, ex, tb):
    text = '{}: {}:\n'.format(ex_cls.__name__, ex)
    import traceback
    text += ''.join(traceback.format_tb(tb))

    print(text)
    QMessageBox.critical(None, 'Error', text)
    quit()

    import sys
    sys.excepthook = log_uncaught_exceptions

#------------------Thread---------------------

class MyCheckUrlThread(QThread):
    about_check_url = pyqtSignal(str) #Проверка ответов
    good_requested_url = pyqtSignal(str) #Запись хороших ответов
    bad_requested_url = pyqtSignal(str) #Запись плохих ответов
    status_bar_info = pyqtSignal(int) #Контроль прогресс-бара
    def __init__(self, working_list, working_list2, working_list3):
        super().__init__()
        self.urls = working_list
        self.urls2 = working_list2
        self.urls3 = working_list3




#-------------Действия в потоке----------------

#-------------Первый контекст------------------

    async def run(self):

        i = 1
        for url in self.urls:
            try:
                shit = await requests.get(url, allow_redirects=False)
                code = await shit.status_code
            except Exception as e:
                # Пусть будет исключение
                code = str(e)
                self.bad_requested_url.emit('{}------{}'.format(url, code))

            self.about_check_url.emit('{}------{}'.format(url, code))

            zaluura = 99 / len(self.urls)

            if i <= 100:
                i += zaluura
                self.status_bar_info.emit(i)

            if code == 200:
                self.good_requested_url.emit('{}------{}'.format(url, code))
            elif code == 307 or 301:
                self.bad_requested_url.emit('{}------{}'.format(url, code))
#-----------------Второй контекст-----------------------
    async def run2(self):

        i = 1
        for url in self.urls2:
            try:
                shit = await requests.get(url, allow_redirects=False)
                code = await shit.status_code
            except Exception as e:
                # Пусть будет исключение
                code = str(e)
                self.bad_requested_url.emit('{}------{}'.format(url, code))

            self.about_check_url.emit('{}------{}'.format(url, code))

            zaluura = 99 / len(self.urls)

            if i <= 100:
                i += zaluura
                self.status_bar_info.emit(i)

            if code == 200:
                self.good_requested_url.emit('{}------{}'.format(url, code))
            elif code == 307 or 301:
                self.bad_requested_url.emit('{}------{}'.format(url, code))

#------------------Третийй контекст-----------------------
    async def run3(self):

        i = 1
        for url in self.urls3:
            try:
                shit = await requests.get(url, allow_redirects=False)
                code = await shit.status_code
            except Exception as e:
                # Пусть будет исключение
                code = str(e)
                self.bad_requested_url.emit('{}------{}'.format(url, code))

            self.about_check_url.emit('{}------{}'.format(url, code))

            zaluura = 99 / len(self.urls)

            if i <= 100:
                i += zaluura
                self.status_bar_info.emit(i)

            if code == 200:
                self.good_requested_url.emit('{}------{}'.format(url, code))
            elif code == 307 or 301:
                self.bad_requested_url.emit('{}------{}'.format(url, code))
    def loop(self):
        loop = asyncio.get_event_loop()
        tasks = [loop.create_task(MyCheckUrlThread.run()), loop.create_task(MyCheckUrlThread.run2()), loop.create_task(MyCheckUrlThread.run3())]
        wait_tasks = asyncio.wait(tasks)
        loop.run_until_complete(wait_tasks)
        loop.close()
#-------------------Объявление UI-----------------------

class MyWin(QMainWindow):
    def __init__(self, parent=None):
        super().__init__()

        self.ui = Ui_RequestCheckerUI()
        self.ui.setupUi(self)
        self.urls = self.ui.textEdit
        self.barista = self.ui.CheckPB

        self.result = self.ui.textEdit_2
        self.good = self.ui.textBrowser
        self.bad = self.ui.textBrowser_2

        self.ui.pushButton.clicked.connect(self._on_click_check)
        self.ui.pushButton_2.clicked.connect(self._erase_fields)

#----------------------Подключения к потоку---------------------------

        self.thread = MyCheckUrlThread(working_list=None, working_list2=None, working_list3=None)
        self.thread.about_check_url.connect(self._on_about_check_url)
        self.thread.good_requested_url.connect(self._good_requested_url)
        self.thread.bad_requested_url.connect(self._bad_requested_url)
        self.thread.status_bar_info.connect(self._statusbarista)
        self.thread.started.connect(self._buttconctrolstop)
        self.thread.finished.connect(self._butocnontrolstart)

#---------Функции интерфейса, выполняемые по сигналу из потока--------

    def _on_click_check(self):
        self.ui.textEdit_2.setText('')
        urls = self.urls.toPlainText().strip().split('\n')
        part0, part1, part2 = np.array_split(urls, 3)
        my_String = '_'.join(part0)  # '' - разделитель между элементами списка соответственно
        my_String2 = '_'.join(part1)
        my_String3 = '_'.join(part2)
        self.ui.textEdit_Visual.setText(my_String)
        self.ui.textEdit_Visual_2.setText(my_String2)
        self.ui.textEdit_Visual_3.setText(my_String3)
        working_list = self.urls.toPlainText().strip().split('\n')
        working_list2 = self.urls.toPlainText().strip().split('\n')
        working_list3 = self.urls.toPlainText().strip().split('\n')
        self.barista.setValue(0)
        self.thread.working_list = working_list
        self.thread.working_list_2 = working_list2
        self.thread.working_list_3 = working_list3
        self.thread.start()


    def _statusbarista(self,int):
        self.barista.setValue(int)


    def _on_about_check_url(self, text):
        self.result.append(text)

    def _good_requested_url(self, text):
        self.good.append(text)

    def _bad_requested_url(self,text):
        self.bad.append(text)

    def _buttconctrolstop(self):
        self.ui.pushButton.setText('Стоп')
        self.ui.pushButton.clicked.connect(self.terminating_thread)
    def _butocnontrolstart(self):
        self.ui.pushButton.setText('Старт')
        self.ui.pushButton.clicked.connect(self.starting_thread)

    def terminating_thread(self):
        self.thread.terminate()

    def starting_thread(self):
        self.thread.start()


    def _erase_fields(self):
        self.ui.textBrowser.setText('')
        self.ui.textBrowser_2.setText('')
        self.ui.textEdit.setText('')
        self.ui.textEdit_2.setText('')

#-------------UI запуск------------------

if __name__ == "__main__":
    app = QtWidgets.QApplication([])
    myapp = MyWin()
    myapp.show()
    app.exec()

